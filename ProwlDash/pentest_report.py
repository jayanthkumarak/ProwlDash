#!/usr/bin/env python3
"""
ProwlDash HTML Report Security Penetration Test
Analyzes generated HTML reports for security vulnerabilities.
"""

import re
import json
import html
from pathlib import Path
from typing import List, Dict, Tuple
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime


class Severity(Enum):
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"


@dataclass
class Vulnerability:
    id: str
    title: str
    severity: Severity
    description: str
    location: str
    recommendation: str
    evidence: str = ""


class HTMLPentest:
    """Security penetration testing for HTML reports."""
    
    def __init__(self, html_file: Path):
        self.html_file = html_file
        self.content = html_file.read_text(encoding='utf-8')
        self.vulnerabilities: List[Vulnerability] = []
        
    def run_all_tests(self) -> List[Vulnerability]:
        """Run all security tests."""
        print(f"üîç Analyzing: {self.html_file.name}")
        
        self.test_xss_innerhtml()
        self.test_xss_unescaped_data()
        self.test_missing_csp()
        self.test_insecure_external_resources()
        self.test_dom_based_xss()
        self.test_insecure_localstorage()
        self.test_missing_security_headers()
        self.test_insecure_json_embedding()
        self.test_clickjacking_protection()
        self.test_hardcoded_secrets()
        self.test_insecure_event_handlers()
        self.test_insecure_url_construction()
        self.test_insecure_dom_manipulation()
        self.test_missing_input_validation()
        
        return self.vulnerabilities
    
    def add_vuln(self, vuln: Vulnerability):
        """Add vulnerability to list."""
        self.vulnerabilities.append(vuln)
    
    def test_xss_innerhtml(self):
        """Test for XSS vulnerabilities via innerHTML usage."""
        # Find all innerHTML assignments
        innerhtml_pattern = r'\.innerHTML\s*=\s*([^;]+)'
        matches = re.finditer(innerhtml_pattern, self.content, re.MULTILINE)
        
        for match in matches:
            assignment = match.group(1).strip()
            location = f"Line ~{self.content[:match.start()].count(chr(10)) + 1}"
            
            # Check if esc() function is used
            if 'esc(' not in assignment and 'textContent' not in assignment:
                # Check if it's a template literal with user data
                if '${' in assignment or 'DATA.' in assignment or 'r.' in assignment:
                    # Check if esc() is applied to user data
                    if not re.search(r'esc\([^)]*\)', assignment):
                        # Exclude safe numeric/boolean values
                        safe_patterns = [
                            r'\$\{(?:DATA\.stats\.total|s\.(?:fail|pass|total|manual|fixed|newFail|critical|high|medium|low|failDelta|passDelta)|d\.(?:count|fixed)|acctStats\.total|i|idx|failPct|passPct|maxFails|w|fp|t|originalTotal|pct|maxSev)\}',
                            r'DATA\.accounts\[.*\]\.short',
                            r'r\.delta\s*===',
                            r'r\.oldStatus',
                            r'acct\.display\s*\|\|\s*acct\.name'
                        ]
                        is_safe = any(re.search(pattern, assignment) for pattern in safe_patterns)
                        if not is_safe:
                            self.add_vuln(Vulnerability(
                                id="XSS-001",
                                title="Potential XSS via innerHTML without proper escaping",
                                severity=Severity.HIGH,
                                description=f"innerHTML assignment found without proper escaping: {assignment[:100]}",
                                location=location,
                                recommendation="Use esc() function for all user-controlled data before innerHTML assignment, or use textContent for non-HTML content.",
                                evidence=assignment[:200]
                            ))
    
    def test_xss_unescaped_data(self):
        """Test for unescaped data in template literals."""
        # Look for template literals with DATA or user variables
        template_pattern = r'`([^`]*\$\{[^}]+\}[^`]*)`'
        matches = re.finditer(template_pattern, self.content, re.MULTILINE | re.DOTALL)
        
        for match in matches:
            template = match.group(1)
            location = f"Line ~{self.content[:match.start()].count(chr(10)) + 1}"
            
            # Check for user data without esc()
            if re.search(r'\$\{(?:r\.|DATA\.|s\.|d\.|x\.|v\.|acct\.|info\.)', template):
                # Check if esc() is used
                if not re.search(r'esc\([^)]*\)', template):
                    # Some exceptions (numbers, booleans are usually safe)
                    if not re.search(r'\$\{(?:DATA\.stats\.total|s\.(?:fail|pass|total|manual|fixed|newFail|critical|high|medium|low|failDelta|passDelta)|d\.(?:count|fixed)|acctStats\.total|i|idx|failPct|passPct|maxFails|w|fp|t|originalTotal|pct|DATA\.accounts\[.*\]\.short|maxSev)\}', template):
                        self.add_vuln(Vulnerability(
                            id="XSS-002",
                            title="Unescaped user data in template literal",
                            severity=Severity.HIGH,
                            description=f"Template literal contains user data without esc() function",
                            location=location,
                            recommendation="Wrap all user-controlled variables in esc() function: esc(${variable})",
                            evidence=template[:200]
                        ))
    
    def test_missing_csp(self):
        """Test for missing Content Security Policy."""
        if '<meta' in self.content:
            csp_pattern = r'<meta[^>]*http-equiv=["\']Content-Security-Policy["\']'
            if not re.search(csp_pattern, self.content, re.IGNORECASE):
                self.add_vuln(Vulnerability(
                    id="SEC-001",
                    title="Missing Content Security Policy (CSP)",
                    severity=Severity.MEDIUM,
                    description="No Content Security Policy header found. CSP helps prevent XSS attacks.",
                    location="<head> section",
                    recommendation="Add CSP meta tag: <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'self' 'unsafe-inline' cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' cdn.jsdelivr.net stackpath.bootstrapcdn.com pro.fontawesome.com; img-src 'self' data: https:; font-src 'self' pro.fontawesome.com; connect-src 'self';\">"
                ))
    
    def test_insecure_external_resources(self):
        """Test for insecure external resource loading."""
        # Check for HTTP (not HTTPS) external resources
        http_pattern = r'http://(?!localhost)[^"\'>\s]+'
        matches = re.finditer(http_pattern, self.content)
        
        for match in matches:
            url = match.group(0)
            if 'http://' in url and 'https://' not in url:
                self.add_vuln(Vulnerability(
                    id="SEC-002",
                    title="Insecure HTTP external resource",
                    severity=Severity.MEDIUM,
                    description=f"External resource loaded over HTTP (insecure): {url}",
                    location=f"URL: {url[:100]}",
                    recommendation="Use HTTPS for all external resources to prevent man-in-the-middle attacks.",
                    evidence=url
                ))
        
        # Check for CDN resources without integrity checks
        cdn_patterns = [
            (r'https://cdn\.jsdelivr\.net[^"\'>\s]+', 'jsdelivr CDN'),
            (r'https://stackpath\.bootstrapcdn\.com[^"\'>\s]+', 'Bootstrap CDN'),
            (r'https://pro\.fontawesome\.com[^"\'>\s]+', 'FontAwesome CDN'),
        ]
        
        for pattern, name in cdn_patterns:
            matches = re.finditer(pattern, self.content)
            for match in matches:
                url = match.group(0)
                # Check for integrity attribute
                context_start = max(0, match.start() - 200)
                context_end = min(len(self.content), match.end() + 200)
                context = self.content[context_start:context_end]
                
                if 'integrity=' not in context and 'crossorigin=' not in context:
                    self.add_vuln(Vulnerability(
                        id="SEC-003",
                        title=f"Missing Subresource Integrity (SRI) for {name}",
                        severity=Severity.MEDIUM,
                        description=f"External script/style loaded without integrity check: {url}",
                        location=f"URL: {url[:100]}",
                        recommendation="Add integrity and crossorigin attributes to prevent tampering: <script src=\"...\" integrity=\"sha384-...\" crossorigin=\"anonymous\"></script>",
                        evidence=url
                    ))
    
    def test_dom_based_xss(self):
        """Test for DOM-based XSS vulnerabilities."""
        # Check for dangerous DOM manipulation
        dangerous_patterns = [
            (r'document\.write\s*\(', 'document.write()'),
            (r'eval\s*\(', 'eval()'),
            (r'Function\s*\(', 'Function() constructor'),
            (r'setTimeout\s*\(\s*["\']', 'setTimeout with string'),
            (r'setInterval\s*\(\s*["\']', 'setInterval with string'),
        ]
        
        for pattern, name in dangerous_patterns:
            matches = re.finditer(pattern, self.content, re.IGNORECASE)
            for match in matches:
                location = f"Line ~{self.content[:match.start()].count(chr(10)) + 1}"
                self.add_vuln(Vulnerability(
                    id="XSS-003",
                    title=f"Potential DOM-based XSS: {name}",
                    severity=Severity.HIGH,
                    description=f"Use of {name} can lead to code injection if user input is involved.",
                    location=location,
                    recommendation=f"Avoid {name}. Use safer alternatives like addEventListener or Function constructors with proper validation.",
                    evidence=self.content[max(0, match.start()-50):match.end()+50]
                ))
    
    def test_insecure_localstorage(self):
        """Test for insecure localStorage usage."""
        # Check if sensitive data is stored in localStorage
        localStorage_pattern = r'localStorage\.(setItem|getItem)\s*\([^)]+\)'
        matches = re.finditer(localStorage_pattern, self.content)
        
        for match in matches:
            location = f"Line ~{self.content[:match.start()].count(chr(10)) + 1}"
            # Check context for sensitive data
            context = self.content[max(0, match.start()-100):match.end()+100]
            
            # For theme storage, this is usually safe, but check for other uses
            if 'theme' not in context.lower() and 'password' in context.lower() or 'secret' in context.lower() or 'token' in context.lower():
                self.add_vuln(Vulnerability(
                    id="SEC-004",
                    title="Potential insecure localStorage usage",
                    severity=Severity.MEDIUM,
                    description="localStorage used - ensure no sensitive data is stored (passwords, tokens, secrets).",
                    location=location,
                    recommendation="Never store sensitive data in localStorage. Use sessionStorage for temporary data, or secure HTTP-only cookies for authentication tokens.",
                    evidence=context[:200]
                ))
    
    def test_missing_security_headers(self):
        """Test for missing security headers."""
        # Check for X-Frame-Options
        if 'X-Frame-Options' not in self.content and 'frame-ancestors' not in self.content:
            self.add_vuln(Vulnerability(
                id="SEC-005",
                title="Missing X-Frame-Options / frame-ancestors",
                severity=Severity.MEDIUM,
                description="No clickjacking protection header found.",
                location="<head> section",
                recommendation="Add: <meta http-equiv=\"X-Frame-Options\" content=\"DENY\"> or use CSP frame-ancestors directive."
            ))
        
        # Check for X-Content-Type-Options
        if 'X-Content-Type-Options' not in self.content:
            self.add_vuln(Vulnerability(
                id="SEC-006",
                title="Missing X-Content-Type-Options",
                severity=Severity.LOW,
                description="Missing X-Content-Type-Options header to prevent MIME type sniffing.",
                location="<head> section",
                recommendation="Add: <meta http-equiv=\"X-Content-Type-Options\" content=\"nosniff\">"
            ))
    
    def test_insecure_json_embedding(self):
        """Test for insecure JSON data embedding."""
        # Check how DATA is embedded
        data_pattern = r'const\s+DATA\s*=\s*({[^;]+});'
        match = re.search(data_pattern, self.content, re.DOTALL)
        
        if match:
            json_str = match.group(1)
            # Check if dangerous characters are properly escaped
            if '</script>' in json_str.lower() or '<script' in json_str.lower():
                self.add_vuln(Vulnerability(
                    id="XSS-004",
                    title="Potential XSS in embedded JSON data",
                    severity=Severity.CRITICAL,
                    description="Embedded JSON data may contain unescaped script tags.",
                    location="const DATA = ...",
                    recommendation="Ensure safe_json_dumps() properly escapes <, >, and / characters. Consider using JSON.parse() with proper escaping.",
                    evidence=json_str[:500]
                ))
    
    def test_clickjacking_protection(self):
        """Test for clickjacking protection."""
        # Check if page can be embedded in iframe
        if 'X-Frame-Options' not in self.content:
            # Check if there's any iframe protection
            if 'frame-ancestors' not in self.content.lower():
                self.add_vuln(Vulnerability(
                    id="SEC-007",
                    title="Missing clickjacking protection",
                    severity=Severity.MEDIUM,
                    description="Page can be embedded in iframes, allowing clickjacking attacks.",
                    location="<head> section",
                    recommendation="Add X-Frame-Options: DENY or CSP frame-ancestors: 'none'"
                ))
    
    def test_hardcoded_secrets(self):
        """Test for hardcoded secrets or sensitive information."""
        # Common patterns for secrets
        secret_patterns = [
            (r'["\'](?:api[_-]?key|apikey|secret[_-]?key|access[_-]?token|password|pwd|passwd)["\']\s*[:=]\s*["\'][^"\']{8,}["\']', 'Potential API key or secret'),
            (r'aws[_-]?access[_-]?key[_-]?id["\']?\s*[:=]\s*["\'][AK][A-Z0-9]{16,}["\']', 'AWS Access Key'),
            (r'aws[_-]?secret[_-]?access[_-]?key["\']?\s*[:=]\s*["\'][A-Za-z0-9/+=]{40,}["\']', 'AWS Secret Key'),
        ]
        
        for pattern, desc in secret_patterns:
            matches = re.finditer(pattern, self.content, re.IGNORECASE)
            for match in matches:
                location = f"Line ~{self.content[:match.start()].count(chr(10)) + 1}"
                self.add_vuln(Vulnerability(
                    id="SEC-008",
                    title=f"Potential hardcoded secret: {desc}",
                    severity=Severity.CRITICAL,
                    description=f"Possible hardcoded secret found: {desc}",
                    location=location,
                    recommendation="Never hardcode secrets in HTML/JavaScript. Use environment variables or secure configuration management.",
                    evidence=self.content[max(0, match.start()-50):match.end()+50]
                ))
    
    def test_insecure_event_handlers(self):
        """Test for insecure inline event handlers."""
        # Check for inline event handlers with user data
        inline_handler_pattern = r'on\w+\s*=\s*["\']([^"\']+)["\']'
        matches = re.finditer(inline_handler_pattern, self.content, re.IGNORECASE)
        
        for match in matches:
            handler = match.group(1)
            # Check if handler contains user data
            if '${' in handler or 'DATA.' in handler:
                location = f"Line ~{self.content[:match.start()].count(chr(10)) + 1}"
                self.add_vuln(Vulnerability(
                    id="XSS-005",
                    title="Insecure inline event handler with user data",
                    severity=Severity.HIGH,
                    description=f"Inline event handler may contain unescaped user data: {handler[:100]}",
                    location=location,
                    recommendation="Use addEventListener() instead of inline handlers, and ensure all user data is properly escaped.",
                    evidence=handler[:200]
                ))
    
    def test_insecure_url_construction(self):
        """Test for insecure URL construction."""
        # Check for URL construction with user input
        url_patterns = [
            r'https?://[^"\'>\s]+\$\{[^}]+\}',
            r'`https?://[^`]*\$\{[^}]+\}[^`]*`',
        ]
        
        for pattern in url_patterns:
            matches = re.finditer(pattern, self.content)
            for match in matches:
                url = match.group(0)
                location = f"Line ~{self.content[:match.start()].count(chr(10)) + 1}"
                
                # Check if URL is validated/escaped
                context = self.content[max(0, match.start()-100):match.end()+100]
                if 'encodeURI' not in context and 'encodeURIComponent' not in context:
                    self.add_vuln(Vulnerability(
                        id="SEC-009",
                        title="Insecure URL construction with user input",
                        severity=Severity.MEDIUM,
                        description="URL constructed with user input without proper encoding.",
                        location=location,
                        recommendation="Use encodeURIComponent() for URL parameters to prevent injection attacks.",
                        evidence=url[:200]
                    ))
    
    def test_insecure_dom_manipulation(self):
        """Test for insecure DOM manipulation patterns."""
        # Check for dangerous patterns
        dangerous_patterns = [
            (r'\.outerHTML\s*=', 'outerHTML assignment'),
            (r'\.insertAdjacentHTML\s*\(', 'insertAdjacentHTML'),
        ]
        
        for pattern, name in dangerous_patterns:
            matches = re.finditer(pattern, self.content, re.IGNORECASE)
            for match in matches:
                location = f"Line ~{self.content[:match.start()].count(chr(10)) + 1}"
                context = self.content[max(0, match.start()-200):match.end()+200]
                
                # Check if user data is involved
                if '${' in context or 'DATA.' in context or 'r.' in context:
                    if 'esc(' not in context:
                        self.add_vuln(Vulnerability(
                            id="XSS-006",
                            title=f"Insecure DOM manipulation: {name}",
                            severity=Severity.HIGH,
                            description=f"{name} used with potentially unescaped user data.",
                            location=location,
                            recommendation="Ensure all user data is escaped before DOM manipulation. Prefer textContent over innerHTML when possible.",
                            evidence=context[:300]
                        ))
    
    def test_missing_input_validation(self):
        """Test for missing input validation."""
        # Check search/filter inputs
        search_pattern = r'filterSearch|filterAccount|filterStatus|filterSeverity'
        if re.search(search_pattern, self.content):
            # Check if input is validated
            input_pattern = r'getElementById\(["\']filterSearch["\']\)\.value'
            if re.search(input_pattern, self.content):
                # Check if value is used without validation
                usage_pattern = r'filterSearch["\']\)\.value[^;]*\.(includes|indexOf|search|match)'
                if re.search(usage_pattern, self.content):
                    # Check if there's any sanitization
                    if 'esc(' not in self.content[max(0, self.content.find('filterSearch')-500):self.content.find('filterSearch')+2000]:
                        self.add_vuln(Vulnerability(
                            id="SEC-010",
                            title="Missing input validation on search/filter",
                            severity=Severity.LOW,
                            description="Search/filter input may not be properly validated or sanitized.",
                            location="filterSearch input handling",
                            recommendation="Validate and sanitize all user inputs. Consider rate limiting for search functionality.",
                            evidence="Search input used in filtering logic"
                        ))


def generate_html_report(vulnerabilities: List[Vulnerability], html_file: Path, output_file: Path):
    """Generate a beautiful HTML security report."""
    
    # Count by severity
    by_severity = {}
    for vuln in vulnerabilities:
        by_severity[vuln.severity] = by_severity.get(vuln.severity, 0) + 1
    
    # Group by ID
    by_id = {}
    for vuln in vulnerabilities:
        if vuln.id not in by_id:
            by_id[vuln.id] = []
        by_id[vuln.id].append(vuln)
    
    # Severity colors
    severity_colors = {
        Severity.CRITICAL: "#dc2626",
        Severity.HIGH: "#ea580c",
        Severity.MEDIUM: "#f59e0b",
        Severity.LOW: "#3b82f6",
        Severity.INFO: "#6b7280"
    }
    
    # Generate HTML
    html_content = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Security Penetration Test Report - {html_file.name}</title>
    <style>
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: #f5f7fa;
            color: #1a1f36;
            line-height: 1.6;
            padding: 20px;
        }}
        
        .container {{
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
        }}
        
        .header {{
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }}
        
        .header h1 {{
            font-size: 32px;
            margin-bottom: 10px;
            font-weight: 700;
        }}
        
        .header .subtitle {{
            font-size: 16px;
            opacity: 0.9;
            margin-top: 8px;
        }}
        
        .header .file-name {{
            background: rgba(255,255,255,0.2);
            padding: 8px 16px;
            border-radius: 6px;
            display: inline-block;
            margin-top: 12px;
            font-family: monospace;
            font-size: 14px;
        }}
        
        .summary {{
            padding: 30px 40px;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
        }}
        
        .summary h2 {{
            font-size: 24px;
            margin-bottom: 20px;
            color: #1a1f36;
        }}
        
        .stats-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }}
        
        .stat-card {{
            background: white;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }}
        
        .stat-card.critical {{ border-left-color: #dc2626; }}
        .stat-card.high {{ border-left-color: #ea580c; }}
        .stat-card.medium {{ border-left-color: #f59e0b; }}
        .stat-card.low {{ border-left-color: #3b82f6; }}
        .stat-card.info {{ border-left-color: #6b7280; }}
        
        .stat-value {{
            font-size: 36px;
            font-weight: 700;
            margin-bottom: 5px;
        }}
        
        .stat-label {{
            font-size: 14px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }}
        
        .content {{
            padding: 40px;
        }}
        
        .section {{
            margin-bottom: 40px;
        }}
        
        .section-title {{
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #1a1f36;
            padding-bottom: 10px;
            border-bottom: 2px solid #e2e8f0;
        }}
        
        .vuln-card {{
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 20px;
            border-left: 4px solid;
            transition: box-shadow 0.2s;
        }}
        
        .vuln-card:hover {{
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }}
        
        .vuln-card.critical {{ border-left-color: #dc2626; }}
        .vuln-card.high {{ border-left-color: #ea580c; }}
        .vuln-card.medium {{ border-left-color: #f59e0b; }}
        .vuln-card.low {{ border-left-color: #3b82f6; }}
        
        .vuln-header {{
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 16px;
        }}
        
        .vuln-id {{
            font-family: monospace;
            font-size: 14px;
            font-weight: 600;
            color: #64748b;
            background: #f1f5f9;
            padding: 4px 10px;
            border-radius: 4px;
        }}
        
        .severity-badge {{
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }}
        
        .severity-badge.critical {{
            background: #fee2e2;
            color: #dc2626;
        }}
        
        .severity-badge.high {{
            background: #fed7aa;
            color: #ea580c;
        }}
        
        .severity-badge.medium {{
            background: #fef3c7;
            color: #f59e0b;
        }}
        
        .severity-badge.low {{
            background: #dbeafe;
            color: #3b82f6;
        }}
        
        .vuln-title {{
            font-size: 18px;
            font-weight: 600;
            margin: 12px 0;
            color: #1a1f36;
        }}
        
        .vuln-detail {{
            margin: 12px 0;
        }}
        
        .vuln-detail strong {{
            color: #475569;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: block;
            margin-bottom: 4px;
        }}
        
        .vuln-detail p {{
            color: #334155;
            font-size: 14px;
            line-height: 1.6;
        }}
        
        .vuln-detail code {{
            background: #f1f5f9;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            color: #1e293b;
        }}
        
        .evidence-box {{
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 12px;
            margin-top: 12px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            color: #475569;
            overflow-x: auto;
            max-height: 200px;
            overflow-y: auto;
        }}
        
        .recommendations {{
            background: #f0fdf4;
            border: 1px solid #bbf7d0;
            border-radius: 8px;
            padding: 24px;
            margin-top: 40px;
        }}
        
        .recommendations h3 {{
            color: #166534;
            margin-bottom: 16px;
            font-size: 18px;
        }}
        
        .recommendations ol {{
            margin-left: 20px;
        }}
        
        .recommendations li {{
            margin: 8px 0;
            color: #166534;
        }}
        
        .footer {{
            background: #f8fafc;
            padding: 20px 40px;
            text-align: center;
            color: #64748b;
            font-size: 14px;
            border-top: 1px solid #e2e8f0;
        }}
        
        .count-badge {{
            background: rgba(255,255,255,0.2);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            margin-left: 8px;
        }}
        
        @media (max-width: 768px) {{
            .container {{
                margin: 10px;
                border-radius: 8px;
            }}
            
            .header {{
                padding: 24px;
            }}
            
            .header h1 {{
                font-size: 24px;
            }}
            
            .content {{
                padding: 20px;
            }}
            
            .stats-grid {{
                grid-template-columns: 1fr;
            }}
        }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîí Security Penetration Test Report</h1>
            <div class="subtitle">Comprehensive Security Analysis</div>
            <div class="file-name">{html_file.name}</div>
            <div class="subtitle" style="margin-top: 16px; font-size: 14px;">
                Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
            </div>
        </div>
        
        <div class="summary">
            <h2>Executive Summary</h2>
            <div class="stats-grid">
                <div class="stat-card critical">
                    <div class="stat-value" style="color: #dc2626;">{by_severity.get(Severity.CRITICAL, 0)}</div>
                    <div class="stat-label">Critical</div>
                </div>
                <div class="stat-card high">
                    <div class="stat-value" style="color: #ea580c;">{by_severity.get(Severity.HIGH, 0)}</div>
                    <div class="stat-label">High</div>
                </div>
                <div class="stat-card medium">
                    <div class="stat-value" style="color: #f59e0b;">{by_severity.get(Severity.MEDIUM, 0)}</div>
                    <div class="stat-label">Medium</div>
                </div>
                <div class="stat-card low">
                    <div class="stat-value" style="color: #3b82f6;">{by_severity.get(Severity.LOW, 0)}</div>
                    <div class="stat-label">Low</div>
                </div>
                <div class="stat-card info">
                    <div class="stat-value" style="color: #1a1f36;">{len(vulnerabilities)}</div>
                    <div class="stat-label">Total Issues</div>
                </div>
            </div>
        </div>
        
        <div class="content">
"""
    
    # Group vulnerabilities by ID
    for vuln_id, vuln_list in sorted(by_id.items()):
        vuln = vuln_list[0]  # Use first instance for details
        count = len(vuln_list)
        severity_class = vuln.severity.value.lower()
        
        html_content += f"""
            <div class="section">
                <div class="section-title">
                    {vuln.id}: {vuln.title}
                    <span class="count-badge" style="background: {severity_colors[vuln.severity]}; color: white;">
                        {count} occurrence{'s' if count > 1 else ''}
                    </span>
                </div>
"""
        
        for i, v in enumerate(vuln_list, 1):
            html_content += f"""
                <div class="vuln-card {severity_class}">
                    <div class="vuln-header">
                        <span class="vuln-id">{v.id} #{i}</span>
                        <span class="severity-badge {severity_class}">{v.severity.value}</span>
                    </div>
                    <div class="vuln-title">{v.title}</div>
                    
                    <div class="vuln-detail">
                        <strong>Description</strong>
                        <p>{html.escape(v.description)}</p>
                    </div>
                    
                    <div class="vuln-detail">
                        <strong>Location</strong>
                        <p><code>{html.escape(v.location)}</code></p>
                    </div>
                    
                    <div class="vuln-detail">
                        <strong>Recommendation</strong>
                        <p>{html.escape(v.recommendation)}</p>
                    </div>
"""
            
            if v.evidence:
                html_content += f"""
                    <div class="vuln-detail">
                        <strong>Evidence</strong>
                        <div class="evidence-box">{html.escape(v.evidence)}</div>
                    </div>
"""
            
            html_content += """
                </div>
"""
        
        html_content += """
            </div>
"""
    
    # Recommendations section
    html_content += f"""
            <div class="recommendations">
                <h3>üìã General Recommendations</h3>
                <ol>
                    <li><strong>Implement Content Security Policy (CSP)</strong> - Add CSP headers to prevent XSS attacks</li>
                    <li><strong>Add Subresource Integrity (SRI)</strong> - Include integrity checks for all external CDN resources</li>
                    <li><strong>Ensure proper data escaping</strong> - Use esc() function for all user-controlled data</li>
                    <li><strong>Add security headers</strong> - Implement X-Frame-Options, X-Content-Type-Options</li>
                    <li><strong>Avoid inline event handlers</strong> - Use addEventListener() instead of inline handlers</li>
                    <li><strong>Use textContent when possible</strong> - Prefer textContent over innerHTML for non-HTML content</li>
                    <li><strong>Validate and sanitize inputs</strong> - Implement proper input validation for all user inputs</li>
                    <li><strong>Never store sensitive data</strong> - Avoid storing passwords, tokens, or secrets in localStorage</li>
                    <li><strong>Use HTTPS for all resources</strong> - Ensure all external resources use secure connections</li>
                    <li><strong>Regular security audits</strong> - Schedule periodic security reviews and penetration tests</li>
                </ol>
            </div>
        </div>
        
        <div class="footer">
            <p>Report generated by ProwlDash Security Penetration Test Tool</p>
            <p style="margin-top: 8px; font-size: 12px;">This report is for security assessment purposes only.</p>
        </div>
    </div>
</body>
</html>
"""
    
    output_file.write_text(html_content, encoding='utf-8')
    print(f"üìÑ HTML security report saved to: {output_file}")


def generate_report(vulnerabilities: List[Vulnerability], output_file: Path):
    """Generate a security report."""
    report = []
    report.append("=" * 80)
    report.append("PROWLDASH HTML REPORT SECURITY PENETRATION TEST RESULTS")
    report.append("=" * 80)
    report.append("")
    
    # Summary
    by_severity = {}
    for vuln in vulnerabilities:
        by_severity[vuln.severity] = by_severity.get(vuln.severity, 0) + 1
    
    report.append("SUMMARY")
    report.append("-" * 80)
    report.append(f"Total Vulnerabilities Found: {len(vulnerabilities)}")
    for severity in [Severity.CRITICAL, Severity.HIGH, Severity.MEDIUM, Severity.LOW, Severity.INFO]:
        count = by_severity.get(severity, 0)
        if count > 0:
            report.append(f"  {severity.value}: {count}")
    report.append("")
    
    # Detailed findings
    report.append("DETAILED FINDINGS")
    report.append("-" * 80)
    report.append("")
    
    for i, vuln in enumerate(vulnerabilities, 1):
        report.append(f"[{i}] {vuln.id}: {vuln.title}")
        report.append(f"    Severity: {vuln.severity.value}")
        report.append(f"    Location: {vuln.location}")
        report.append(f"    Description: {vuln.description}")
        report.append(f"    Recommendation: {vuln.recommendation}")
        if vuln.evidence:
            report.append(f"    Evidence: {vuln.evidence[:200]}...")
        report.append("")
    
    # Recommendations
    report.append("=" * 80)
    report.append("GENERAL RECOMMENDATIONS")
    report.append("=" * 80)
    report.append("1. Implement Content Security Policy (CSP) headers")
    report.append("2. Add Subresource Integrity (SRI) for all external resources")
    report.append("3. Ensure all user data is escaped using esc() function")
    report.append("4. Add security headers (X-Frame-Options, X-Content-Type-Options)")
    report.append("5. Avoid inline event handlers with user data")
    report.append("6. Use textContent instead of innerHTML when possible")
    report.append("7. Validate and sanitize all user inputs")
    report.append("8. Never store sensitive data in localStorage")
    report.append("")
    
    output_file.write_text("\n".join(report), encoding='utf-8')
    print(f"üìÑ Security report saved to: {output_file}")


def generate_markdown_report(vulnerabilities: List[Vulnerability], html_file: Path, output_file: Path):
    """Generate a markdown security report for agent consumption."""
    from datetime import datetime
    
    # Count by severity
    by_severity = {}
    for vuln in vulnerabilities:
        by_severity[vuln.severity] = by_severity.get(vuln.severity, 0) + 1
    
    # Group by ID
    by_id = {}
    for vuln in vulnerabilities:
        if vuln.id not in by_id:
            by_id[vuln.id] = []
        by_id[vuln.id].append(vuln)
    
    md = []
    md.append("# Security Penetration Test Report")
    md.append("")
    md.append(f"**File Analyzed:** `{html_file.name}`")
    md.append(f"**Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    md.append("")
    
    # Executive Summary
    md.append("## Executive Summary")
    md.append("")
    md.append(f"**Total Vulnerabilities Found:** {len(vulnerabilities)}")
    md.append("")
    md.append("| Severity | Count |")
    md.append("|----------|-------|")
    for severity in [Severity.CRITICAL, Severity.HIGH, Severity.MEDIUM, Severity.LOW, Severity.INFO]:
        count = by_severity.get(severity, 0)
        if count > 0:
            md.append(f"| {severity.value} | {count} |")
    md.append("")
    
    # Detailed Findings
    md.append("## Detailed Findings")
    md.append("")
    
    for vuln_id, vuln_list in sorted(by_id.items()):
        vuln = vuln_list[0]
        count = len(vuln_list)
        
        md.append(f"### {vuln.id}: {vuln.title}")
        md.append("")
        md.append(f"**Severity:** `{vuln.severity.value}`")
        md.append(f"**Occurrences:** {count}")
        md.append("")
        md.append(f"**Description:** {vuln.description}")
        md.append("")
        md.append(f"**Location:** `{vuln.location}`")
        md.append("")
        md.append(f"**Recommendation:**")
        md.append("")
        md.append(f"```")
        md.append(vuln.recommendation)
        md.append("```")
        md.append("")
        
        if vuln.evidence:
            md.append("**Evidence:**")
            md.append("")
            md.append("```javascript")
            md.append(vuln.evidence[:500])
            md.append("```")
            md.append("")
        
        # List all occurrences
        if count > 1:
            md.append("**All Occurrences:**")
            md.append("")
            for i, v in enumerate(vuln_list, 1):
                md.append(f"{i}. {v.location}")
            md.append("")
        
        md.append("---")
        md.append("")
    
    # Remediation Guide
    md.append("## Remediation Guide")
    md.append("")
    md.append("### Priority 1: Critical/High Severity Issues")
    md.append("")
    
    critical_high = [v for v in vulnerabilities if v.severity in [Severity.CRITICAL, Severity.HIGH]]
    if critical_high:
        md.append("#### XSS Vulnerabilities")
        md.append("")
        md.append("**Action Items:**")
        md.append("")
        md.append("1. **Fix unescaped innerHTML assignments:**")
        md.append("   - Find all `innerHTML` assignments with user data")
        md.append("   - Wrap user data with `esc()` function")
        md.append("   - Example fix:")
        md.append("   ```javascript")
        md.append("   // BEFORE (vulnerable):")
        md.append("   element.innerHTML = 'Text: ' + DATA.scanInfo;")
        md.append("   ")
        md.append("   // AFTER (fixed):")
        md.append("   element.innerHTML = 'Text: ' + esc(DATA.scanInfo);")
        md.append("   // OR use textContent for non-HTML:")
        md.append("   element.textContent = 'Text: ' + DATA.scanInfo;")
        md.append("   ```")
        md.append("")
        md.append("2. **Fix unescaped template literals:**")
        md.append("   - Find all template literals with `${variable}`")
        md.append("   - Wrap user variables: `${esc(variable)}`")
        md.append("   - Example fix:")
        md.append("   ```javascript")
        md.append("   // BEFORE (vulnerable):")
        md.append("   const html = `<div>${r.title}</div>`;")
        md.append("   ")
        md.append("   // AFTER (fixed):")
        md.append("   const html = `<div>${esc(r.title)}</div>`;")
        md.append("   ```")
        md.append("")
    
    md.append("### Priority 2: Medium Severity Issues")
    md.append("")
    md.append("#### Security Headers")
    md.append("")
    md.append("Add the following to the `<head>` section of `templates/dashboard_template.html`:")
    md.append("")
    md.append("```html")
    md.append("<!-- Content Security Policy -->")
    md.append("<meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'self' 'unsafe-inline' cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' cdn.jsdelivr.net stackpath.bootstrapcdn.com pro.fontawesome.com; img-src 'self' data: https:; font-src 'self' pro.fontawesome.com; connect-src 'self';\">")
    md.append("")
    md.append("<!-- Clickjacking Protection -->")
    md.append("<meta http-equiv=\"X-Frame-Options\" content=\"DENY\">")
    md.append("")
    md.append("<!-- MIME Type Sniffing Protection -->")
    md.append("<meta http-equiv=\"X-Content-Type-Options\" content=\"nosniff\">")
    md.append("```")
    md.append("")
    
    md.append("#### External Resources")
    md.append("")
    md.append("1. **Fix HTTP resources:**")
    md.append("   - Change `http://www.w3.org/2000/svg` to `https://www.w3.org/2000/svg`")
    md.append("   - Or remove namespace (modern browsers don't require it)")
    md.append("")
    md.append("2. **Add Subresource Integrity (SRI):**")
    md.append("   - Add `integrity` and `crossorigin` attributes to CDN scripts")
    md.append("   - Example:")
    md.append("   ```html")
    md.append("   <script src=\"https://cdn.jsdelivr.net/npm/chart.js\"")
    md.append("           integrity=\"sha384-...\"")
    md.append("           crossorigin=\"anonymous\"")
    md.append("           defer></script>")
    md.append("   ```")
    md.append("   - Get integrity hash from: https://www.srihash.org/")
    md.append("")
    
    md.append("#### URL Construction")
    md.append("")
    md.append("Fix insecure URL construction in MITRE ATT&CK links:")
    md.append("")
    md.append("```javascript")
    md.append("// BEFORE (vulnerable):")
    md.append("const url = `https://attack.mitre.org/techniques/${m.replace('.', '/')}/`;")
    md.append("")
    md.append("// AFTER (fixed):")
    md.append("const url = `https://attack.mitre.org/techniques/${encodeURIComponent(m.replace('.', '/'))}/`;")
    md.append("```")
    md.append("")
    
    # File Locations
    md.append("## Files to Modify")
    md.append("")
    md.append("1. **`templates/dashboard_template.html`** - Main template file")
    md.append("   - Add security headers in `<head>` section")
    md.append("   - Fix all XSS vulnerabilities in JavaScript")
    md.append("   - Fix HTTP resources")
    md.append("   - Add SRI to CDN scripts")
    md.append("")
    md.append("2. **`prowldash.py`** - May need updates if data escaping logic changes")
    md.append("")
    
    # Testing
    md.append("## Testing")
    md.append("")
    md.append("After making fixes:")
    md.append("")
    md.append("1. Regenerate HTML reports: `python3 prowldash.py <csv_files>`")
    md.append("2. Re-run security test: `python3 pentest_report.py <generated_html>`")
    md.append("3. Verify vulnerabilities are resolved")
    md.append("4. Test in browser to ensure functionality is preserved")
    md.append("")
    
    # Checklist
    md.append("## Remediation Checklist")
    md.append("")
    md.append("- [ ] Fix all innerHTML assignments with user data")
    md.append("- [ ] Fix all template literals with unescaped user data")
    md.append("- [ ] Add Content Security Policy header")
    md.append("- [ ] Add X-Frame-Options header")
    md.append("- [ ] Add X-Content-Type-Options header")
    md.append("- [ ] Fix HTTP resources (use HTTPS)")
    md.append("- [ ] Add SRI to CDN scripts")
    md.append("- [ ] Fix insecure URL construction")
    md.append("- [ ] Test all fixes")
    md.append("- [ ] Re-run penetration test")
    md.append("")
    
    md.append("---")
    md.append("")
    md.append("*Report generated by ProwlDash Security Penetration Test Tool*")
    
    output_file.write_text("\n".join(md), encoding='utf-8')
    print(f"üìÑ Markdown security report saved to: {output_file}")


def main():
    """Main entry point."""
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python pentest_report.py <html_file> [html_file2 ...]")
        print("\nExample:")
        print("  python pentest_report.py output/12_25_25/cis_dashboard.html")
        sys.exit(1)
    
    all_vulnerabilities = []
    tested_files = []
    
    for html_path in sys.argv[1:]:
        html_file = Path(html_path)
        if not html_file.exists():
            print(f"‚ùå File not found: {html_file}")
            continue
        
        pentest = HTMLPentest(html_file)
        vulns = pentest.run_all_tests()
        all_vulnerabilities.extend(vulns)
        tested_files.append(html_file)
        
        print(f"   Found {len(vulns)} potential vulnerabilities")
    
    if all_vulnerabilities:
        # Generate reports
        output_dir = Path("output")
        output_dir.mkdir(exist_ok=True)
        
        # Generate HTML report
        html_report_file = output_dir / "security_pentest_report.html"
        generate_html_report(all_vulnerabilities, tested_files[0], html_report_file)
        
        # Generate markdown report
        md_report_file = output_dir / "security_pentest_report.md"
        generate_markdown_report(all_vulnerabilities, tested_files[0], md_report_file)
        
        # Generate text report
        text_report_file = output_dir / "security_pentest_report.txt"
        generate_report(all_vulnerabilities, text_report_file)
        
        # Print summary to console
        print("\n" + "=" * 80)
        print("SECURITY TEST SUMMARY")
        print("=" * 80)
        by_severity = {}
        for vuln in all_vulnerabilities:
            by_severity[vuln.severity] = by_severity.get(vuln.severity, 0) + 1
        
        for severity in [Severity.CRITICAL, Severity.HIGH, Severity.MEDIUM, Severity.LOW]:
            count = by_severity.get(severity, 0)
            if count > 0:
                print(f"  {severity.value}: {count}")
        
        print(f"\n‚úÖ Reports generated:")
        print(f"   üìÑ HTML (human-readable): {html_report_file}")
        print(f"   üìÑ Markdown (for agent): {md_report_file}")
        print(f"   üìÑ Text: {text_report_file}")
    else:
        print("\n‚úÖ No vulnerabilities found!")


if __name__ == "__main__":
    main()
